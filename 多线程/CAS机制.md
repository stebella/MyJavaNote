## 什么是CAS

比如使用Synchornized就会引起线程阻塞的问题，CAS就是为了解决这个问题应运而生的

compareAndSwap 比较交换

CAS，是Compare and Swap的简称，在这个机制中有三个核心的参数：

- 主内存中存放的共享变量的值：V（一般情况下这个V是内存的地址值，通过这个地址可以获得内存中的值）

- 工作内存中共享变量的副本值，也叫预期值：A

- 需要将共享变量更新到的最新值：B

  ![img](E:\笔记\Java面试笔记\images\hhh.jpg)

  如上图中，主存中保存V值，线程中要使用V值要先从主存中读取V值到线程的工作内存A中，然后计算后变成B值，最后再把B值写回到内存V值中。多个线程共用V值都是如此操作。CAS的核心是在将B值写入到V之前要比较A值和V值是否相同，如果不相同证明此时V值已经被其他线程改变，重新将V值赋给A，并重新计算得到B，如果相同，则将B值赋给V。

  值得注意的是CAS机制中的这步步骤是原子性的（从指令层面提供的原子操作），所以CAS机制可以解决多线程并发编程对共享变量读写的原子性问题。

过程：它包含 3 个参数 CAS（V，E，N），V表示要更新变量的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做两个更新，则当前线程则什么都不做。最后，CAS 返回当前V的真实值。

CAS 操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。所以CAS也叫作乐观锁，那什么是悲观锁呢？悲观锁就是我们之前赫赫有名的synchronized。悲观锁的思想你可以这样理解，一个线程想要去获得这个锁但是却获取不到，必须要别人释放了才可以。

最终是由操作系统的汇编指令完成的。

## 实现

Java提供的CAS操作类--Unsafe类



## CAS使用场景

- 使用一个变量统计网站的访问量；
- Atomic类操作；
- 数据库乐观锁更新。

## CAS机制的优缺点

（1）优点

一开始在文中我们曾经提到过，cas是一种乐观锁，而且是一种非阻塞的轻量级的乐观锁，什么是非阻塞式的呢？其实就是一个线程想要获得锁，对方会给一个回应表示这个锁能不能获得。在资源竞争不激烈的情况下性能高，相比synchronized重量锁，synchronized会进行比较复杂的加锁，解锁和唤醒操作。

（2）缺点

**1. ABA问题**

缺点也是一个非常重要的知识点，因为涉及到了一个非常著名的问题，叫做ABA问题。假设一个变量 A ，修改为 B之后又修改为 A，CAS 的机制是无法察觉的，但实际上已经被修改过了。这就是ABA问题

ABA问题会带来大量的问题，比如说数据不一致的问题等等。我们可以举一个例子来解释说明。

你有一瓶水放在桌子上，别人把这瓶水喝完了，然后重新倒上去。你再去喝的时候发现水还是跟之前一样，就误以为是刚刚那杯水。如果你知道了真相，那是别人用过了你还会再用嘛？

在jdk中提供了AtomicStampedReference类解决ABA问题，用Pair这个内部类实现，包含两个属性，分别代表版本号和引用，在compareAndSet中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。

**2. 可能会消耗较高的CPU**
看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU。因此可以看出，如果线程之间竞争程度小，使用CAS是一个很好的选择；但是如果竞争很大，使用锁可能是个更好的选择。在并发量非常高的环境中，如果仍然想通过原子类来更新的话，可以使用AtomicLong的替代类：LongAdder。

**3. 不能保证代码块的原子性**
Java中的CAS机制只能保证共享变量操作的原子性，而不能保证代码块的原子性。