##  为什么要进行序列化

 再介绍之前，我们有必要先了解下对象的生命周期，我们知道Java中的对象都是存在于堆内存中的，而堆内存是可以被垃圾回收器不定期回收的。从对象被创建到被回收这一段时间就是Java对象的生命周期，也即Java对象只存活于这个时间段内。

  对象被垃圾回收器回收意味着对象和对象中的成员变量所占的内存也就被回收，这意味着我们就再也得不到该对象的任何内容了，因为已经被销毁了嘛，当然我们可以再重新创建，但这时的对象的各种属性都又被重新初始化了。所以如果我们需要保存某对象的状态，然后再在未来的某段时间将该对象再恢复出来的话，则必须要在对象被销毁即被垃圾回收器回收之前保存对象的状态。要保存对象状态的话，我们可以使用文件、数据库，也可以使用序列化，这里我们主要介绍对象序列化。我们很有必要了解这方面的内容，因为对象序列化不仅在保存对象状态时可以被用到（对象持久化），在Java中的远程方法调用RMI也会被用到，在网络中要传输对象的话，则必须要对对象进行序列化，关于RMI有机会我会再专门开贴介绍。

>  简单总结起来，进行对象序列化的话的主要原因就是**实现对象持久化和进行网络传输**，这里先只介绍怎样通过对象序列化保存对象的状态。

要序列化某个类的对象的话，则该类必要实现Serializable接口

下面我们看一下如何来进行序列化，这其中主要涉及到  Java  的  I/O  方面的内容，主要用到两个类  FileOutputStream  和  ObjectOutputStream  ，  FileOutputStream  用于将字节输出到文件，  ObjectOutputStream  通过调用  writeObject  方法将对象转换为可以写出到流的数据。

所以整个流程是这样的：  ObjectOutputStream  将要序列化的对象转换为某种数据，然后通过  FileOutputStream  连接某磁盘文件，再对象转化的数据转化为字节数据再将其写出到磁盘文件。

## 对象的反序列化

我们存储的目的主要是为了再恢复使用

，主要用到的流是FileInputstream和ObjectInputstream正好与存储时用到的流相对应。另外从结果顺序我们可以看到反序列化后得到对象的顺序与序列化时的顺序一致。

## 总结

>  补充一：上面我们举得例子很简单，要保存的成员变量要么是基本类型的要么是String类型的。但有时成员变量有可能是引用类型的，这是的情况会复杂一点。那就是当要对某对象进行序列化时，该对象中的引用变量所引用的对象也会被同时序列化，并且该对象中如果也有引用变量的话则该对象也将被序列化。总结说来就是在序列化的时候，对象中的所有引用变量所对应的对象将会被同时序列化。这意味着，`引用变量类型也都要实现Serializable接口`。当然其他对象的序列化都是自动进行的。所以我们只要保证里面的引用类型是都实现Serializable接口就行了，如果没有的话，会在编译时抛出异常。如果序列化的对象中包含没有实现Serializable的成员变量的话，这时可以使用transient关键字，让序列化的时候跳过该成员变量。使用关键字transient可以让你在序列化的时候自动跳过transient所修饰的成员变量，在反序列化时这些变量会恢复到默认值。
>
>  补充二：如果某类实现了Serializable接口的话，其子类会自动编程可序列化的，这个好理解，继承嘛。
>
>  补充三：在反序列化的时候，并不会调用对象的构造器，这也好理解，如果调用了构造器的话，对象的状态不就又重新初始化了吗。
>
>  补充四：我们说到对象序列化的是为了保存对象的状态，即对象的成员变量，所以静态变量不会被序列化。 



进行对象序列化主要目的是为了保存对象的状态（成员变量）。

 进行序列化主要用到的流是FileOutputStream和ObjectOutputStream。FileOutputStream主要用于连接磁盘文件，并把字节写出到该磁盘文件；ObjectOutputStream主要用于将对象写出为可转化为字节的数据。

 要将某类的对象序列化，则该类必须实现Serializable接口，该接口仅是一个标志，告诉JVM该类的对象可以被序列化。如果某类未实现Serializable接口，则该类对象不能实现序列化。

 保存状态的目的就是为了在未来的某个时候再恢复保存的内容，这可以通过反序列化来实现。对象的反序列化过程与序列化正好相反，主要用到的两个流是FileInputstream和ObjectInputStream。

 反序列化后得到的对象的顺序与保存时的顺序一致。