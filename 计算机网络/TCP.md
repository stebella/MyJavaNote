## 三次握手四次挥手

为了**保证数据能到达目标**，TCP采用三次握手策略。

1、由客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）SYN：同步序列编号（Synchronize Sequence Numbers）。

2、由服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接。

3、客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1） 

![img](E:\笔记\Java面试笔记\images\20200729160012638.png)

### Q：为什么要三次握手？

三次握手的目的是`建立可靠的通信信道`，说到通讯，简单来说就是数据的发送与接收，而**三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的**

1. 第一次握手，发送端：什么都确认不了；接收端：**对方发送正常，自己接受正常**
2. 第二次握手，发送端：**对方发送，接受正常，自己发送，接受正常** ；接收端：对方发送正常，自己接受正常
3. 第三次握手，发送端：对方发送，接受正常，自己发送，接受正常；接收端：**对方**发送，**接受正常**，**自己发送**，接受正常

### Q：两次握手不行吗？为什么TCP客户端最后还要发送一次确认呢？

主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。
经典场景：`客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了`

- 由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。
- 此时此前滞留的那一次请求连接，网络通畅了到达服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。
- 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

### Q：TCP三次握手中，最后一次回复丢失，会发生什么？

- 如果最后一次ACK在网络中丢失，那么**Server端（服务端）该TCP连接的状态仍为SYN_RECV**，并且**根据 TCP的超时重传机制依次等待3秒、6秒、12秒后重新发送 SYN+ACK 包**，以便 **Client（客户端）重新发送ACK包**
- **如果重发指定次数后，仍然未收到ACK应答**，那么一段时间后，**Server（服务端）自动关闭这个连接**
- **但是Client（客户端）认为这个连接已经建立**，如果Client（客户端）端向Server（服务端）发送数据，**Server端（服务端）将以RST包（Reset，标示复位，用于异常的关闭连接）响应**，此时，**客户端知道第三次握手失败**

## 四次挥手

![img](E:\笔记\Java面试笔记\images\20200729160031110.png)

1、客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）

2、服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）

3、服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到A的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）

4、客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成）

### Q：为什么连接的时候是三次握手，关闭的时候却是四次握手？

- 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把**ACK和SYN放在一个报文里**发送给客户端。
- 关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了,所以服务器可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。因此，服务器**ACK和FIN一般都会分开发送**，从而导致多了一次。

### Q：为什么TCP挥手每两次中间有一个 FIN-WAIT2等待时间？

- 主动关闭的一端调用完close以后（即发FIN给被动关闭的一端， 并且收到其对FIN的确认ACK）则进入FIN_WAIT_2状态。**如果这个时候因为网络突然断掉、被动关闭的一段宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的FIN（防止对端不发送关闭连接的FIN包给本端）**，这个时候就需要FIN_WAIT_2定时器， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的FIN，那么直接释放这个链接，进入CLOSE状态

### Q：为什么客户端最后还要等待2MSL？为什么还有个TIME-WAIT的时间等待？

1. **保证客户端发送的最后一个ACK报文能够到达服务器**，因为这个ACK报文可能丢失，**服务器已经发送了FIN+ACK报文，请求断开，客户端却没有回应，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文**，并且会重启2MSL计时器。
2. 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以**使本连接持续的时间内所产生的所有报文段都从网络中消失，这样新的连接中不会出现旧连接的请求报文**。
3. 2MSL，最大报文生存时间，一个MSL 30 秒，2MSL = 60s

## 其它

Initial Sequence Number，简称ISN。就是上文的seq的初始化。

