[寄存器](#寄存器（register）)

[堆栈](#堆栈（stack）)

[堆](#堆（heap）)

[静态存储区](#静态存储区（static storage）)

[常量存储区](#常量存储区（constant storage）)

[非RAM存储区](#非RAM存储区)

## 寄存器（register）

- 最快的存储区，不同于其他存储区位于在**处理器内部**
- 数量极其有限，按需分配
- java中**不能直接控制**，也不能在程序中感觉到寄存器存在的任何迹象
- **C语言可以定义寄存器变量**

## 堆栈（stack）

- 位于通用RAM中

- **存放`基本类型的变量数据`和`对象的引用`，但对象本身不存放在栈中**

- 由编译器自动分配释放，出/入栈，释放/分配内存，快速有效的分配存储方法，仅次于寄存器

- 创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下移动堆栈指针

  > 当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。
  >
  > 栈有一个很重要的特殊性，就是存在`栈中的数据可以共享`。假设我们同时定义： 
  > int a = 3; 
  > int b = 3； 
  > 编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来（放在栈里），然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4；那么编译器 会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。**要注意这 种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的**，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。 
  
  > **注意String**
  >
  > (1) 我们在使用诸如String str =  "abc"；的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向  String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。
  >
  > 因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为"abc"的String类。清醒地认识到这一点对排除程序中难以发现的bug是很有帮助的。 
  >
  > (2) 使用String str = "abc"；的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据常量池中数据的实际情况来决定是否有必要创建新对象。
  >
  > 而对于String str = new String("abc")；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。 
  >
  > (3) 当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。 
  >
  > (4) 由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。 
  >
  >  **我们再来看看 String str = new String("abc")创建过程**
  >
  > **(1) 先定义一个名为str的对String类的对象引用变量放入栈中。**
  >
  > **(2) 然后在`堆`中（不是常量池）创建一个指定的对象，并让str引用指向该对象。** 
  >
  > **(3) 在`常量池`中查找是否存在内容为"abc"字符串对象。**
  > **(4) 如果不存在，`则在常量池中创建内容为"abc"的字符串对象，并将堆中的对象与之联系起来。`**
  > **(5) 如果存在，`则将new出来的字符串对象与字符串常量池中的对象联系起来`（即让那个特殊的成员变量value的指针指向它）**
  >

## 堆（heap）

- 通用性内存池，也存在于RAM中，**存放所有new出来的对象**

- 在`堆中分配的内存，由java虚拟机自动垃圾回收器来管理`

- 堆分配具有很大灵活性，执行new代码时，会自动在堆里进行存储分配

- **用堆进行存储分配比用堆栈分配需要更多的时间**

  > 堆内存和栈内存确实是我们常常用的东西,比如 Animal a = new Animal(); 这个时候相当于在堆内存中开辟了一个空间保存了Animal的信息以及着块空间的内存地址,然后在栈内存中划了一小快空间保存了堆中的内存地址,这个时候我们就可以说引用a指向Animal()了. 可是有时候,有个静态类.Animal,里面有个静态方法speak(); 那么可以这么直接调用Animal.sepak(); 这个时候既没有new,也没有Animal a=??; 所以既没有在堆中开辟空间也没有在栈内存中开辟空间 , 可是方法确实能执行,一切程序都运行在内存里,那么证明有新的内存区,就是静态空间了.
  >
  > ***数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因。***
  >
  > ### 堆栈对比：
  >
  > - 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。
  >
  > - `栈的优势是，存取速度比堆要快`，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢 。

## 静态存储区（static storage）

- 也叫方法区，存储的是在整个程序中永远唯一的元素。例如class/static变量

- "静态"是指"`在固定的位置`"，存放程序运行时一直存在的数据，可用关键字static来标识一个对象的特定元素是静态的，但Java对象本身不会存放在静态存储空间里

  > 值得深思的是，static能修饰成员变量，而不能修饰方法中的临时变量，所以static final修饰的是一个成员变量，这个变量放在常量存储区中。而仅用static修饰成员变量时放在静态存储区中。

## 常量存储区（constant storage）

- 通常存放在程序代码内部，安全，因为永远不会被改变

- 在嵌入式系统中，常量本身会和其它部分分割开。所以在这种情况下，可以选择将其放在ROM中

  > **声明为final static的为常量，可以保存在常量储存区**，还有String类型的对象都是常量，系统维护了一个**String常量池**。 String类型是final修饰的，无法被继承。
  >
  > ```java
  > String s = new String("Hello world!");
  > ```
  >
  > 上面这行代码一共创建了几个对象？答案是不确定的，因为不知道常量池中存不存在Hello world!字符常量。如果存在，则只创建一个String类型的对象在堆上，如果不存在则在堆上创建一个String对象，并在常量池创建一个字符常量Hello world!对象。需要注意的是，常量池在java类加载的过程中会有很多字符常量被创建，需要比对的字符常量可能已经存在，只是你不知道而已。

## 非RAM存储区

- 非RAM存储器，主要就是磁带、磁盘等等

- 数据完全活在程序外部，不依赖程序时，它可以不受程序的任何控制，即使程序未运行依然可以存在，比如流对象和持久化对象。

  > 对于流对象来说，对象转化为字节流，发送给另一台机器；对于持久化对象来说，通常存放于磁盘上，即使程序终止，仍可以保持自己的状态。此存储方式的技巧在于：**把对象转化为可以存放在任何其它媒介的事物上，在需要时，恢复为常规的、基于RAM的对象。** 













