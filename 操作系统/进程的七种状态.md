进程状态保存在进程任务结构的`state`字段中![img](E:\笔记\Java面试笔记\images\Center.jpg)

**运行——>就绪**：1，主要是进程占用CPU的时间过长，而系统分配给该进程占用CPU的时间是有限的；2，在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行时，该进程就被迫让出CPU，该进程便由执行状态转变为就绪状态。

**就绪——>运行**：运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配CPU

**运行——>阻塞**：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如发生了I/O请求

**阻塞——>就绪**:进程所等待的事件已经发生，就进入就绪队列

以下两种状态是不可能发生的：

​    阻塞——>运行：即使给阻塞进程分配CPU，也无法执行，操作系统在进行调度时不会从阻塞队列进行挑选，而是从就绪队列中选取

​    就绪——>阻塞：就绪态根本就没有执行，谈不上进入阻塞态。



在一些系统中，又增加了一些新状态，如`挂起状态，可运行状态，深度睡眠状态，浅度睡眠状态，暂停状态，僵死状态`。

**可运行状态**：运行状态和就绪状态的合并，表示进程正在运行或准备运行，Linux 中使用TASK_RUNNING 宏表示可运行状态。

**浅度睡眠状态**：可中断睡眠状态，进程正在睡眠（被阻塞），等待资源的到来是唤醒，也可以通过其他进程信号或时钟中断唤醒，进入运行队列。Linux 中使用TASK_INTERRUPTIBLE 宏表示此状态。

**深度睡眠状态**：其和浅度睡眠基本类似，但不可被其他进程信号或时钟中断唤醒。Linux 中使用TASK_UNINTERRUPTIBLE 宏表示此状态。该状态通常在进程需要不受干扰地等待或者所等待事件会很快发生时使用。

**暂停状态**：进程暂停执行接受某种处理。Linux 使用TASK_STOPPED 宏表示此状态。当进程收到信号SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU时就会进入暂停状 态。可向其发送SIGCONT信号让进程转换到可运行状态。进程在调试期间接收到任何信号均会进入该状态。

**僵死状态**：进程已经结束但未释放进程控制块（PCB），Linux 使用TASK_ZOMBIE 宏表示此状态。当进程已停止运行，但其父进程还没有调用wait()询问其状态时，则称该进程处于僵死状态。为了了让 父进程能够获取其停止运行的信息，此时子进程的任务数据结构信息还需要保留着。一旦父进程调用wait()取得了子进程的信息，则处于该状态进程的任务数 据结构就会被释放。

**挂起状态**：在执行状态的进程通过挂起即可进入就绪状态，如图所示，就绪状态和阻塞状态都分为活动态和静止态。由活动态向静止态转换就是通过挂起实现的。

当一个进程的运行时间片用完，系统就会使用调度程序强制切换到其他的进程去执行。另外，如果进程在内核态执行时需要等待系统的某个资源，此时该进程 就会调用sleep_on()或interruptible_sleep_on()自愿地放弃CPU的使用权，而让调度程序去执行其他进程。进程则进入睡 眠状态。


　　只有当进程从"内核运行态"转移到"睡眠状态"时，内核才会进行进程切换操作。在内核态下运行的进程不能被其他进程抢占，而且一个进程不能改变另一个进程的状态。为了避免进程切换时造成内核数据错误，内核在执行临界区代码时会禁止一切中断。 
原文链接：https://blog.csdn.net/qq_39380590/article/details/79755747

![img](E:\笔记\Java面试笔记\images\Center3.jpg)

![img](E:\笔记\Java面试笔记\images\Center1.jpg)